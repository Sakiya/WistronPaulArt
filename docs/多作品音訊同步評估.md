# 多作品音訊同步 Swiper 切換功能評估

## 需求分析

### 需要同步的作品
- **作品 1**：3 個時間節點
- **作品 2**：5 個時間節點
- **作品 3**：3 個時間節點
- **作品 4**：3 個時間節點
- **作品 6**：5 個時間節點
- **作品 5、7、8**：不需要

### 總計
- **5 個作品**需要同步功能
- **19 個時間節點**（3+5+3+3+5）
- **中英文版本時間點可能不同**

## 技術可行性評估

### ✅ **完全可行**

**現有技術基礎：**
1. ✅ 每個作品都有獨立的播放器實例（`workAudioPlayer1`, `workAudioPlayer2`, ...）
2. ✅ 每個作品都有獨立的 Swiper 實例（`window.workSwipers[workId]`）
3. ✅ 語言系統已完善（`currentLang` 變數追蹤當前語言）
4. ✅ 播放器初始化時可以獲取當前語言

## 實現方案設計

### 方案 A：集中配置物件（推薦）

**優點：**
- 所有配置集中管理，易於維護
- 支援中英文不同時間點
- 易於手動調整
- 結構清晰

**配置結構：**
```javascript
/**
 * 作品音訊同步配置
 * 格式：{ 作品ID: { 語言: [時間節點陣列] } }
 * 
 * 時間節點格式：{ time: 秒數, slideIndex: slide 索引 }
 * slideIndex 從 0 開始（0 = 第一個 slide）
 */
const workSyncConfig = {
    // 作品 1：3 個節點
    // 範例：假設音訊 3 分鐘，Slide1=0:00, Slide2=1:00, Slide3=2:00
    1: {
        zh: [
            { time: 0, slideIndex: 0 },    // 0:00 對應 Slide1
            { time: 60, slideIndex: 1 },   // 1:00 切換到 Slide2
            { time: 120, slideIndex: 2 }    // 2:00 切換到 Slide3
        ],
        en: [
            { time: 0, slideIndex: 0 },     // 英文版時間可能不同
            { time: 62, slideIndex: 1 },
            { time: 125, slideIndex: 2 }
        ]
    },
    
    // 作品 2：5 個節點
    // 範例：假設音訊 5 分鐘，5 個 slides
    2: {
        zh: [
            { time: 0, slideIndex: 0 },     // 0:00 對應 Slide1
            { time: 60, slideIndex: 1 },    // 1:00 切換到 Slide2
            { time: 120, slideIndex: 2 },   // 2:00 切換到 Slide3
            { time: 180, slideIndex: 3 },   // 3:00 切換到 Slide4
            { time: 240, slideIndex: 4 }    // 4:00 切換到 Slide5
        ],
        en: [
            { time: 0, slideIndex: 0 },
            { time: 62, slideIndex: 1 },
            { time: 125, slideIndex: 2 },
            { time: 190, slideIndex: 3 },
            { time: 255, slideIndex: 4 }
        ]
    },
    
    // 作品 3：3 個節點
    // 範例：假設音訊 3 分鐘，Slide1=0:00, Slide2=1:00, Slide3=2:00
    3: {
        zh: [
            { time: 0, slideIndex: 0 },      // 0:00 對應 Slide1
            { time: 60, slideIndex: 1 },    // 1:00 切換到 Slide2
            { time: 120, slideIndex: 2 }    // 2:00 切換到 Slide3
        ],
        en: [
            { time: 0, slideIndex: 0 },
            { time: 62, slideIndex: 1 },
            { time: 125, slideIndex: 2 }
        ]
    },
    
    // 作品 4：3 個節點
    4: {
        zh: [
            { time: 0, slideIndex: 0 },
            { time: 60, slideIndex: 1 },
            { time: 120, slideIndex: 2 }
        ],
        en: [
            { time: 0, slideIndex: 0 },
            { time: 62, slideIndex: 1 },
            { time: 125, slideIndex: 2 }
        ]
    },
    
    // 作品 6：5 個節點
    6: {
        zh: [
            { time: 0, slideIndex: 0 },
            { time: 60, slideIndex: 1 },
            { time: 120, slideIndex: 2 },
            { time: 180, slideIndex: 3 },
            { time: 240, slideIndex: 4 }
        ],
        en: [
            { time: 0, slideIndex: 0 },
            { time: 62, slideIndex: 1 },
            { time: 125, slideIndex: 2 },
            { time: 190, slideIndex: 3 },
            { time: 255, slideIndex: 4 }
        ]
    }
};
```

**實現邏輯：**
```javascript
function setupWorkAudioSync(playerId, workId) {
    // 檢查該作品是否需要同步
    if (!workSyncConfig[workId]) {
        return; // 作品 5、7、8 不需要同步
    }
    
    const player = videojs.getPlayer(playerId);
    if (!player) {
        return;
    }
    
    const swiper = window.workSwipers[workId];
    if (!swiper) {
        return;
    }
    
    // 獲取當前語言的時間點配置
    const lang = currentLang; // 'zh' 或 'en'
    const timePoints = workSyncConfig[workId][lang] || workSyncConfig[workId]['zh'];
    
    if (!timePoints || timePoints.length === 0) {
        return;
    }
    
    // 追蹤已觸發的時間點，避免重複切換
    const triggeredPoints = new Set();
    
    // 標記是否為用戶手動切換（避免循環觸發）
    let isUserSlideChange = false;
    let isAutoSlideChange = false;
    
    // ========== 功能 1：音訊播放到時間點 → 自動切換 slide ==========
    // 監聽播放時間更新
    player.on('timeupdate', function() {
        // 如果正在手動切換 slide，跳過自動切換
        if (isUserSlideChange) {
            return;
        }
        
        const currentTime = player.currentTime();
        
        // 檢查每個時間點
        for (let i = 0; i < timePoints.length; i++) {
            const point = timePoints[i];
            const pointKey = `${workId}-${lang}-${i}`;
            
            // 檢查是否到達時間點（允許 0.5 秒誤差）
            if (currentTime >= point.time - 0.5 && currentTime < point.time + 0.5) {
                // 檢查是否已經觸發過
                if (!triggeredPoints.has(pointKey)) {
                    // 檢查當前 slide 是否已經是目標
                    if (swiper.activeIndex !== point.slideIndex) {
                        isAutoSlideChange = true;
                        swiper.slideTo(point.slideIndex);
                        isAutoSlideChange = false;
                    }
                    triggeredPoints.add(pointKey);
                }
                break; // 只處理第一個匹配的時間點
            }
        }
    });
    
    // ========== 功能 2：用戶手動切換 slide → 音訊跳轉到對應時間點 ==========
    // 監聽 Swiper slide 切換事件
    swiper.on('slideChange', function() {
        // 如果是自動切換觸發的，不處理
        if (isAutoSlideChange) {
            return;
        }
        
        // 標記為用戶手動切換
        isUserSlideChange = true;
        
        const currentSlideIndex = swiper.activeIndex;
        
        // 找到對應的時間點
        // 查找該 slide 對應的時間點（找到第一個匹配的）
        let targetTime = 0;
        for (let i = 0; i < timePoints.length; i++) {
            if (timePoints[i].slideIndex === currentSlideIndex) {
                targetTime = timePoints[i].time;
                break;
            }
        }
        
        // 如果找不到對應的時間點，使用 slide 索引 × 60 秒（假設每個 slide 對應 1 分鐘）
        // 或者可以根據實際需求調整
        if (targetTime === 0 && currentSlideIndex > 0) {
            // 這裡可以根據實際需求調整邏輯
            // 例如：Slide 0 = 0:00, Slide 1 = 1:00, Slide 2 = 2:00
            targetTime = currentSlideIndex * 60;
        }
        
        // 跳轉音訊到對應時間點
        if (player && !player.paused()) {
            player.currentTime(targetTime);
        } else {
            player.currentTime(targetTime);
        }
        
        // 重置觸發記錄，因為時間點改變了
        triggeredPoints.clear();
        
        // 延遲重置標記，避免立即觸發自動切換
        setTimeout(function() {
            isUserSlideChange = false;
        }, 500);
    });
    
    // ========== 功能 3：重置功能 ==========
    // 當播放重新開始時，重置觸發記錄
    player.on('play', function() {
        // 如果從頭開始播放，重置觸發記錄和 slide
        if (player.currentTime() < 1) {
            triggeredPoints.clear();
            if (swiper.activeIndex !== 0) {
                isAutoSlideChange = true;
                swiper.slideTo(0);
                isAutoSlideChange = false;
            }
        }
    });
    
    // 當用戶手動跳轉時，重置觸發記錄
    player.on('seeked', function() {
        triggeredPoints.clear();
        // 根據當前時間找到對應的 slide
        const currentTime = player.currentTime();
        let targetSlideIndex = 0;
        
        // 找到最接近的時間點對應的 slide
        for (let i = timePoints.length - 1; i >= 0; i--) {
            if (currentTime >= timePoints[i].time - 0.5) {
                targetSlideIndex = timePoints[i].slideIndex;
                break;
            }
        }
        
        if (swiper.activeIndex !== targetSlideIndex) {
            isAutoSlideChange = true;
            swiper.slideTo(targetSlideIndex);
            isAutoSlideChange = false;
        }
    });
}
```

**在 `initSingleWorkPlayer` 中調用：**
```javascript
// 在播放器 ready 後添加
player.ready(function() {
    // ... 現有代碼 ...
    
    // 設置音訊同步（如果該作品需要）
    setupWorkAudioSync(playerId, workId);
});
```

**在切換作品或關閉時重置：**
```javascript
// 在 switchTab 函數中，當切換離開作品詳情時
function switchTab(targetTab, shouldUpdateHash = true) {
    // ... 現有代碼 ...
    
    // 如果切換離開作品詳情，重置所有作品
    if (targetTab !== 'workDetail') {
        // 停止所有作品播放器並重置
        for (let i = 1; i <= 9; i++) {
            const playerId = 'workAudioPlayer' + i;
            try {
                const player = videojs.getPlayer(playerId);
                if (player) {
                    player.pause();
                    player.currentTime(0); // 重置時間
                }
            } catch (e) {
                // 忽略錯誤
            }
            
            // 重置 Swiper 到第一個 slide
            if (window.workSwipers && window.workSwipers[i]) {
                window.workSwipers[i].slideTo(0);
            }
        }
    }
}

// 在 showWorkDetail 函數中，當顯示新作品時
function showWorkDetail(workId) {
    // ... 現有代碼 ...
    
    // 確保播放器時間為 0
    const playerId = 'workAudioPlayer' + workId;
    const player = videojs.getPlayer(playerId);
    if (player) {
        player.currentTime(0);
    }
    
    // 確保 Swiper 在第一個 slide
    if (window.workSwipers && window.workSwipers[workId]) {
        window.workSwipers[workId].slideTo(0);
    }
}
```

### 方案 B：使用 data 屬性配置（不推薦）

**缺點：**
- HTML 結構會變複雜
- 不易維護大量時間點
- JSON 解析增加複雜度

## 性能影響評估

### ⚠️ **性能影響：低到中等（可接受）**

#### 1. **事件監聽器數量**
- **5 個作品** × **1 個監聽器** = **5 個 `timeupdate` 監聽器**
- 每個監聽器約每秒觸發 4 次
- **總計：每秒約 20 次事件處理**

#### 2. **每次事件處理的開銷**

**CPU 使用：**
- 獲取當前時間：`O(1)` - 極低
- 遍歷時間點陣列：`O(n)` - n 平均約 3.8（19/5）
- 檢查 Swiper 狀態：`O(1)` - 極低
- Set 操作（檢查/添加）：`O(1)` - 極低
- 切換 slide：`O(1)` - 低（DOM 操作）

**單次處理時間：** < 1ms
**每秒總處理時間：** < 20ms（約 2% CPU）

#### 3. **記憶體使用**

**配置物件：**
- 19 個時間點 × 約 50 bytes = 約 950 bytes
- Set 物件（觸發記錄）：最多 19 個項目 × 約 20 bytes = 約 380 bytes
- **總計：約 1.3KB**

#### 4. **電池消耗（移動設備）**
- 5 個事件監聽器同時運行
- 每秒約 20 次檢查
- **預期影響：低**（< 2% CPU 使用）

### 性能優化建議

#### 優化 1：範圍檢查（推薦）
只在接近時間點時才進行詳細檢查：

```javascript
player.on('timeupdate', function() {
    const currentTime = player.currentTime();
    
    // 快速檢查：是否在任何時間點的 ±5 秒範圍內
    const isNearAnyPoint = timePoints.some(point => 
        Math.abs(currentTime - point.time) < 5
    );
    
    if (!isNearAnyPoint) {
        return; // 跳過檢查，節省 CPU
    }
    
    // 詳細檢查邏輯...
});
```

**效果：** 可減少 80-90% 的檢查次數

#### 優化 2：降低檢查頻率
使用節流（throttle）降低檢查頻率：

```javascript
let lastCheckTime = 0;
const checkInterval = 0.3; // 每 0.3 秒檢查一次

player.on('timeupdate', function() {
    const currentTime = player.currentTime();
    if (currentTime - lastCheckTime < checkInterval) {
        return;
    }
    lastCheckTime = currentTime;
    // 檢查邏輯...
});
```

**效果：** 可減少 70% 的檢查次數

#### 優化 3：使用 requestAnimationFrame（可選）
對於非關鍵時間點，可以使用 `requestAnimationFrame` 延遲處理。

## 維護性評估

### ✅ **維護性：優秀**

#### 優點：
1. **集中配置：** 所有時間點在一個物件中，易於查找和修改
2. **結構清晰：** 按作品和語言分組，一目了然
3. **易於調整：** 只需修改配置物件中的數值
4. **支援版本控制：** 配置變更可以追蹤

#### 手動調整方式：
```javascript
// 例如：調整作品 3 中文版第一個時間點從 2:22 改為 2:25
3: {
    zh: [
        { time: 145, slideIndex: 1 },  // 從 142 改為 145（2:25）
        // ...
    ]
}
```

#### 建議的配置管理流程：
1. 在配置物件中定義所有時間點
2. 測試並微調時間點
3. 提交到版本控制
4. 如需調整，直接修改配置物件

## 語言切換處理

### ✅ **已考慮語言切換**

**實現方式：**
- 在 `setupWorkAudioSync` 中，使用 `currentLang` 獲取對應語言的配置
- 如果當前語言沒有配置，回退到中文配置
- 語言切換時，播放器會重新載入音訊檔案，同步功能會自動使用新語言的配置

**注意事項：**
- 語言切換時，需要重置觸發記錄
- 確保語言切換後，同步功能立即生效

## 核心功能邏輯

### 功能 1：音訊播放到時間點 → 自動切換 slide
- 當音訊播放到特定時間點時（例如 1:00），自動切換到對應的 slide（例如 Slide2）
- 使用 `timeupdate` 事件監聽播放時間
- 使用 Set 追蹤已觸發的時間點，避免重複切換

### 功能 2：用戶手動切換 slide → 音訊跳轉到對應時間點
- 當用戶手動切換 slide 時（例如切換到 Slide3），音訊自動跳轉到對應的時間點（例如 2:00）
- 使用 Swiper 的 `slideChange` 事件監聽手動切換
- 使用標記區分自動切換和手動切換，避免循環觸發

### 功能 3：切換作品或關閉時歸零
- 當用戶切換到其他作品或關閉作品詳情時：
  - 音訊播放時間重置為 0:00
  - Swiper 切換到第一個 slide（Slide1）
- 需要在 `switchTab` 或 `showWorkDetail` 函數中實現

## 潛在問題與解決方案

### 問題 1：循環觸發（音訊跳轉 → slide 切換 → 音訊跳轉）
**解決方案：**
- 使用 `isUserSlideChange` 和 `isAutoSlideChange` 標記區分觸發來源
- 自動切換時設置 `isAutoSlideChange = true`，跳過音訊跳轉邏輯
- 手動切換時設置 `isUserSlideChange = true`，跳過自動切換邏輯
- 使用 `setTimeout` 延遲重置標記，避免立即觸發

### 問題 2：時間點對應關係
**解決方案：**
- 優先使用配置物件中的時間點
- 如果找不到對應的時間點，可以使用計算方式（例如：slideIndex × 60 秒）
- 需要根據實際音訊長度和 slide 數量調整

### 問題 3：播放暫停/跳轉
**解決方案：**
- 監聽 `seeked` 事件，重置觸發記錄
- 根據跳轉後的時間，自動切換到對應的 slide
- 監聽 `play` 事件，如果從頭開始則重置

### 問題 4：切換作品時歸零
**解決方案：**
- 在 `switchTab` 函數中，當切換離開作品詳情時：
  - 停止所有作品播放器
  - 重置所有 Swiper 到第一個 slide
- 在 `showWorkDetail` 函數中，當顯示新作品時：
  - 確保播放器時間為 0
  - 確保 Swiper 在第一個 slide

### 問題 5：時間精度
**解決方案：**
- 使用時間範圍檢查（±0.5 秒）
- 使用 Set 避免重複觸發
- 手動切換時，直接跳轉到精確時間點

### 問題 6：多個作品同時播放（理論上不會發生）
**解決方案：**
- 當前設計中，一次只顯示一個作品
- 如果未來需要，可以添加播放器互斥邏輯

## 實現建議

### 推薦方案：**方案 A + 優化 1**

1. **使用集中配置物件**
2. **添加範圍檢查優化**
3. **支援中英文不同時間點**
4. **易於手動調整**

### 實施步驟：
1. 創建 `workSyncConfig` 配置物件
2. 實現 `setupWorkAudioSync` 函數（包含雙向同步邏輯）
3. 在 `initSingleWorkPlayer` 中調用
4. 在 `switchTab` 和 `showWorkDetail` 中添加重置邏輯
5. 測試每個作品的同步功能：
   - 測試音訊播放到時間點自動切換 slide
   - 測試手動切換 slide 時音訊跳轉
   - 測試切換作品時歸零
6. 微調時間點
7. 測試語言切換

## 結論

### ✅ **強烈建議實施**

**理由：**
1. ✅ 技術完全可行，實現簡單
2. ✅ 性能影響低（CPU < 2%，記憶體 < 2KB）
3. ✅ 維護性優秀，易於手動調整
4. ✅ 支援中英文不同時間點
5. ✅ 用戶體驗提升明顯

**預期性能影響：**
- CPU 使用增加：< 2%（優化後 < 0.5%）
- 記憶體增加：< 2KB
- 電池消耗：可忽略不計

**配置管理：**
- 所有時間點集中在一個配置物件
- 易於手動調整和維護
- 支援版本控制
