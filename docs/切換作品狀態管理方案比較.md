# 切換作品狀態管理方案比較

## 需求場景
當用戶切換作品或關閉作品詳情時，需要決定：
- **方案 A：歸零** - 重置到 0:00 和 Slide1
- **方案 B：保持狀態** - 停在當下的時間和 slide 位置

## 方案 A：歸零（推薦）

### 實現方式
```javascript
// 在 switchTab 中，切換離開作品詳情時
if (targetTab !== 'workDetail') {
    for (let i = 1; i <= 9; i++) {
        const player = videojs.getPlayer('workAudioPlayer' + i);
        if (player) {
            player.pause();
            player.currentTime(0); // 歸零
        }
        
        if (window.workSwipers && window.workSwipers[i]) {
            window.workSwipers[i].slideTo(0); // 回到第一個 slide
        }
    }
}

// 在 showWorkDetail 中，顯示新作品時
function showWorkDetail(workId) {
    // 先停止其他作品
    for (let i = 1; i <= 9; i++) {
        if (i !== workId) {
            const player = videojs.getPlayer('workAudioPlayer' + i);
            if (player) {
                player.pause();
                player.currentTime(0);
            }
            if (window.workSwipers && window.workSwipers[i]) {
                window.workSwipers[i].slideTo(0);
            }
        }
    }
    
    // 確保當前作品也是從頭開始
    const player = videojs.getPlayer('workAudioPlayer' + workId);
    if (player) {
        player.currentTime(0);
    }
    if (window.workSwipers && window.workSwipers[workId]) {
        window.workSwipers[workId].slideTo(0);
    }
}
```

### 優點 ✅
1. **實現簡單**
   - 只需調用 `currentTime(0)` 和 `slideTo(0)`
   - 代碼量少，邏輯清晰
   - 不易出錯

2. **狀態一致**
   - 每次打開作品都是乾淨的狀態
   - 不會有殘留狀態造成的混淆
   - 用戶知道從哪裡開始

3. **用戶體驗清晰**
   - 符合「重新開始」的直覺
   - 避免「為什麼停在奇怪位置」的困惑
   - 特別適合展覽導覽場景

4. **維護成本低**
   - 不需要狀態管理邏輯
   - 不需要處理狀態同步問題
   - 不需要考慮多作品狀態衝突

5. **性能更好**
   - 不需要保存和恢復狀態
   - 不需要額外的記憶體開銷

### 缺點 ⚠️
1. **無法繼續播放**
   - 如果用戶想從上次位置繼續，需要重新找到位置
   - 但對於展覽導覽場景，這通常不是問題

2. **可能不符合某些使用習慣**
   - 某些用戶可能期望保持狀態
   - 但可以通過其他方式解決（如書籤功能）

### 適用場景
- ✅ 展覽導覽（每次都是新的體驗）
- ✅ 教學內容（從頭開始更清晰）
- ✅ 一次性觀看內容

---

## 方案 B：保持狀態

### 實現方式
```javascript
// 需要保存每個作品的狀態
const workStates = {
    1: { currentTime: 0, slideIndex: 0 },
    2: { currentTime: 0, slideIndex: 0 },
    // ...
};

// 在切換作品時保存狀態
function saveWorkState(workId) {
    const player = videojs.getPlayer('workAudioPlayer' + workId);
    const swiper = window.workSwipers[workId];
    
    if (player && swiper) {
        workStates[workId] = {
            currentTime: player.currentTime(),
            slideIndex: swiper.activeIndex
        };
    }
}

// 在顯示作品時恢復狀態
function showWorkDetail(workId) {
    // 保存當前作品的狀態
    const currentWorkId = getCurrentWorkId();
    if (currentWorkId) {
        saveWorkState(currentWorkId);
    }
    
    // 恢復新作品的狀態
    const savedState = workStates[workId] || { currentTime: 0, slideIndex: 0 };
    
    const player = videojs.getPlayer('workAudioPlayer' + workId);
    const swiper = window.workSwipers[workId];
    
    if (player) {
        player.currentTime(savedState.currentTime);
    }
    if (swiper) {
        swiper.slideTo(savedState.slideIndex);
    }
}
```

### 優點 ✅
1. **用戶體驗連續**
   - 可以從上次位置繼續
   - 符合某些用戶的使用習慣

2. **適合長時間內容**
   - 對於長音訊，可以分段觀看
   - 不需要每次都從頭開始

### 缺點 ⚠️
1. **實現複雜**
   - 需要狀態保存和恢復機制
   - 需要處理多個作品的狀態管理
   - 需要考慮狀態同步問題

2. **潛在問題**
   - 狀態可能不一致（音訊時間和 slide 不同步）
   - 切換作品時，如果保持上一個作品的狀態，可能造成混淆
   - 需要處理「關閉後重新打開」的場景

3. **維護成本高**
   - 需要額外的狀態管理代碼
   - 需要處理各種邊界情況
   - 調試困難

4. **用戶體驗可能不佳**
   - 如果用戶關閉後重新打開，可能期望從頭開始
   - 狀態不一致可能造成困惑

5. **性能開銷**
   - 需要額外的記憶體保存狀態
   - 需要額外的邏輯處理

### 適用場景
- ✅ 長時間內容（如課程、有聲書）
- ✅ 需要分段觀看的內容
- ⚠️ 展覽導覽（通常不需要）

---

## 混合方案：智能歸零（推薦進階方案）

### 實現邏輯
```javascript
// 只在「切換到其他作品」時歸零
// 在「關閉作品詳情」時保持狀態（可選）

function switchTab(targetTab) {
    if (targetTab !== 'workDetail') {
        // 切換離開作品詳情，歸零所有作品
        resetAllWorks();
    }
    // 如果切換到其他 tab，可以選擇保持狀態或歸零
}

function showWorkDetail(newWorkId) {
    // 保存當前作品的狀態（如果需要的話）
    const currentWorkId = getCurrentWorkId();
    if (currentWorkId && currentWorkId !== newWorkId) {
        // 切換到不同作品，歸零舊作品
        resetWork(currentWorkId);
    }
    
    // 新作品從頭開始
    resetWork(newWorkId);
}
```

### 優點
- 結合兩種方案的優點
- 切換作品時歸零（避免混淆）
- 關閉時可選保持狀態（如果需要的話）

---

## 建議

### 🎯 **強烈推薦：方案 A（歸零）**

**理由：**

1. **實現簡單**
   - 代碼量少，邏輯清晰
   - 不易出錯，維護成本低

2. **符合展覽導覽場景**
   - 展覽導覽通常是「一次性體驗」
   - 每次打開都是新的開始
   - 用戶期望從頭開始

3. **用戶體驗清晰**
   - 狀態一致，不會有混淆
   - 符合「重新開始」的直覺

4. **性能更好**
   - 不需要額外的狀態管理
   - 不需要額外的記憶體開銷

5. **未來擴展容易**
   - 如果需要「繼續播放」功能，可以後續添加
   - 可以通過 localStorage 實現「書籤」功能

### 如果確實需要「繼續播放」功能

可以考慮以下方案：

1. **使用 localStorage 保存進度**（可選功能）
   ```javascript
   // 保存進度
   localStorage.setItem(`work_${workId}_progress`, currentTime);
   
   // 恢復進度（可選）
   const savedProgress = localStorage.getItem(`work_${workId}_progress`);
   if (savedProgress && userWantsToContinue) {
       player.currentTime(savedProgress);
   }
   ```

2. **添加「繼續播放」按鈕**（可選功能）
   - 顯示「從上次位置繼續」的選項
   - 讓用戶選擇是否繼續

3. **只在「關閉後重新打開」時保持狀態**
   - 切換作品時歸零
   - 關閉後重新打開同一作品時，可以選擇保持狀態

---

## 結論

### 推薦方案：**方案 A（歸零）**

**實現優先級：**
1. ✅ **先實現歸零方案**（簡單、可靠）
2. ⏸️ **後續可選**：如果需要，再添加「繼續播放」功能

**建議的實現方式：**
- 切換作品時：歸零所有作品
- 關閉作品詳情時：歸零所有作品
- 顯示新作品時：確保從頭開始

這樣可以確保：
- 實現簡單
- 狀態一致
- 用戶體驗清晰
- 未來容易擴展
